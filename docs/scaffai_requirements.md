# ScaffAI（モバイル+Web統合アプリ）要件定義書

## プロジェクト概要

ScaffAIは、モバイルアプリ(iOS/Android)とWebアプリを単一のコードベースで開発・提供するクロスプラットフォームプロジェクトである。本ドキュメントでは、その要件をAI開発支援ツール（例: Claude Code、Cursor、bolt.new）が理解・解析しやすいよう構造化し、コード補完の精度向上に寄与する形式で記述する。

本システムはExpo SDK 53（React Native）とNext.js 15（React）を組み合わせ、Turborepoによるモノレポ構成を採用している。

## 技術スタックとバージョン仕様

### フロントエンド
- **Expo SDK**: 53（React Native v0.74対応）
- **Next.js**: 15.1.8（App Router使用）
- **React**: 19.x（Server Componentsおよび非同期コンポーネント対応）
- **TypeScript**: 5.x（型安全性の確保）

### UI・スタイリング
- **NativeWind**: 4.x（React Native向けTailwind CSS）
- **Radix UI**: 1.x（アクセシブルなWeb UIプリミティブ）
- **Tailwind CSS**: 4.x（ユーティリティファーストCSS）

### バックエンド・データベース
- **Supabase**: 2.x（認証・データベース・ストレージ・リアルタイム）
- **FastAPI**: 0.1x（Python APIサーバー）
- **PostgreSQL**: 15.x（Supabaseで提供）

### 開発環境・ツール
- **Turborepo**: 2.x（モノレポ管理）
- **ESLint**: 9.x（コード品質管理）
- **Prettier**: 3.x（コードフォーマット）

### デプロイ・CI/CD
- **Vercel**: 最新（Webアプリデプロイ）
- **Expo EAS**: 最新（モバイルアプリビルド・配信）

### 状態管理・データフェッチ
- **TanStack Query**: 5.x（サーバー状態管理）
- **Zustand**: 4.x（クライアント状態管理）

### Expo SDK 53の主要機能と対応状況
Expo SDK 53は React Native v0.74をベースとしており、以下の主要機能が利用可能である：

- **Expo Router**: ファイルベースルーティング（v3対応）
- **Expo Notifications**: プッシュ通知機能
- **Expo Camera**: カメラ機能
- **Expo SQLite**: ローカルデータベース
- **Expo SecureStore**: 安全なローカルストレージ
- **Expo Location**: 位置情報サービス
- **Expo AV**: 音声・動画再生
- **Expo Image Picker**: 画像選択機能
- **Expo Updates**: OTAアップデート
- **Expo Background Tasks**: バックグラウンド処理

### Next.js 15の新機能と対応
Next.js 15では以下の変更点に対応している：

- **非同期コンポーネント**: `params`、`searchParams`、`cookies()`、`headers()`等の非同期化
- **React 19サポート**: Server Componentsとクライアントコンポーネントの最適化
- **App Router安定化**: ディレクトリベースルーティングの完全対応
- **Turbopack**: 高速バンドラーの採用（開発時）
- **セキュリティ強化**: CSRF保護やセキュアヘッダーの自動設定モバイルアプリはExpo RouterとNativeWind、WebアプリはNext.jsのApp RouterとRadix UIを利用し、UIコンポーネントとビジネスロジックは共通のパッケージ（@scaffai/ui, @scaffai/core）に集約している。また、バックエンドにはSupabase（認証・データベース・ストレージ・リアルタイム機能）およびFastAPIベースの独自APIサーバを活用し、パフォーマンス、オフライン対応、アクセシビリティといった非機能要件にも配慮した設計としている。

## 機能要件

### 認証とユーザー管理

**機能概要**: ユーザーの登録・ログイン・ログアウト、およびプロフィール管理機能を提供する。モバイル・Web両プラットフォームで単一の認証基盤を使用し、いずれからサインインしても共通のユーザーアカウントで利用できること。新規登録、メール確認、パスワードリセットなどの基本的なユーザー管理フローを含む。

**実装アプローチ**: 認証基盤にはSupabaseのAuth機能を利用する。SupabaseはオープンソースのFirebase代替となるBaaSで、Postgresベースのデータベース、認証、リアルタイム通信等の機能を統合提供する 。モバイル・Web双方でSupabaseのJavaScript SDKを用いて認証APIを呼び出し、ユーザーデータを取得・保持する。具体的には、メールアドレス＋パスワードによるサインアップ/サインインや、必要に応じてOAuthプロバイダによるログインを実装する。認証状態（セッション情報）はアプリ内で保持し、@scaffai/coreにセッション管理用のモジュールを設けて共有する。各プラットフォームにおいてログイン画面・登録画面・プロフィール画面を実装し、共通のユーザー情報（プロフィール画像や表示名など）が閲覧・編集できるようにする。

### データ管理とリアルタイム同期

**機能概要**: アプリ固有のドメインデータ（例：プロジェクトやドキュメントなど）をユーザーが作成・閲覧・編集できるようにする。モバイルとWebで同等のデータ操作機能を提供し、いずれのプラットフォームからのデータ更新も即座に他方に反映されること（リアルタイム同期）。

**実装アプローチ**: データストアにはSupabaseのPostgresデータベースを使用し、基本的なCRUD操作はSupabaseが提供する自動生成APIまたはクライアントライブラリ経由で行う。@scaffai/core内にデータアクセス層を実装し、各種エンティティ（テーブル）ごとに取得・作成・更新・削除処理をカプセル化する。またSupabaseのリアルタイム機能を活用し、特定のテーブルに対する変更を購読してクライアント側で自動更新する 。例えば、ユーザーAがWebでデータを更新した際、モバイルアプリの対応画面でもほぼ即時に変更が反映されるようにする。リアルタイム同期はSupabaseのPostgres変更送信機能（リスナー）を用いて実現し、各クライアントではWebソケット接続により変更イベントを受信して状態を更新する。オフライン時は後述のとおりローカルにデータをキャッシュし、再接続時に差分同期を行う。

### ファイルアップロードとストレージ

**機能概要**: ユーザーが画像やドキュメントなどのファイルをアップロード・閲覧できるようにする。アップロードしたファイルはクラウドストレージに保存され、モバイル・Webの双方からアクセス可能であること。例えば、ユーザーのプロフィール画像や投稿画像をアプリ内で表示できるようにする。

**実装アプローチ**: Supabaseのストレージ機能を利用し、ファイルはSupabase上のストレージバケットに保存する。アップロード／ダウンロード処理はSupabaseのストレージAPIを通じて行い、認可制御はSupabase Authと連携したルール（Row Level Security）で実現する。モバイル側ではデバイスの画像ライブラリやカメラからファイル選択し、取得したファイルをSupabaseストレージに送信する実装とする（ExpoのファイルシステムAPIやImage Pickerコンポーネントを利用）。Web側では&lt;input type="file"&gt;等を用いてファイル選択し、JavaScriptからSupabaseストレージにアップロードする。アップロード後はファイルの公開URLまたは認証付きURLを取得し、アプリ内で表示・ダウンロード可能とする。大容量ファイルについてはプログレス表示やアップロードの一時停止・再開などUXに配慮した実装を検討する。

### UI一貫性とコンポーネント共有

**機能概要**: モバイルアプリとWebアプリで一貫したUIデザインとユーザビリティを提供する。プラットフォームごとにネイティブな見た目を損なわずに、共通のデザインシステム（スタイルガイドやコンポーネント）に基づいた画面を構築する。ボタンやフォーム入力、カードUIなど主要なコンポーネントは可能な限り共通化し、再利用性と保守性を高める。

**実装アプローチ**: @scaffai/uiパッケージにデザインシステムとなる共通UIコンポーネント群を定義する。WebアプリではRadix UIをベースにアクセシブルなUIパーツを構築し、デザインに沿って必要なスタイリングを当てる 。Radix UIは未加工かつアクセシブルなReactプリミティブ群を提供するライブラリで、高品質なWebアプリのデザインシステム構築に適している 。モバイルアプリではReact Native標準のコンポーネント（ViewやText等）をラップし、スタイルにTailwind CSSのユーティリティクラスを適用できるNativeWindを導入する 。NativeWindを使用することで、React Nativeコンポーネントに対しTailwind CSSライクなスタイル指定が可能となり、プラットフォーム間でデザインの共通化を図れる 。両プラットフォームで色やタイポグラフィ、余白といったデザイントークンを共有し、@scaffai/ui内にテーマ設定（Tailwindの設定ファイルやRadix Tokens等）を一元管理する。なお、プラットフォーム固有のUI慣習（例えばモバイルにおけるタブバーや、Webにおけるホバー挙動）は各アプリ側で実装しつつ、可能な限りコンポーネントのAPIや見た目の統一を図る。結果として、ユーザーはどのデバイスでも違和感のない操作体験を得られる。

### バックエンドAPIと外部サービス連携

**機能概要**: アプリの中核機能において、データベース直接操作だけでなく追加のサーバサイド処理や外部サービスとの連携が必要となる場合、専用のバックエンドAPIを提供する。例えば、複雑なビジネスロジックの実行やAIを用いたコード自動生成等の重い処理を行う際に、クライアントからバックエンドにリクエストし処理結果を受け取る仕組みを用意する。

**実装アプローチ**: Python製のFastAPIフレームワークを用いて独自のREST APIサーバを構築し、必要なエンドポイントを実装する。FastAPI 0.115.x以上を使用し、最新のPythonの型ヒントとPydantic 2.xに基づいてAPIを構築する。これを利用して、例えば`/api/generate-scaffold`のようなエンドポイントでAI関連の処理を行い、結果をJSONで返す処理などを実装する。モバイル・Web双方からHTTP経由でこのAPIを呼び出し、返却されたデータを画面に反映する。認証が必要なAPIについては、Supabaseで発行されるJWTトークンを利用した認可ガードを導入し、各リクエストにユーザーの認証情報を含めて送信する。FastAPI側でそのトークンを検証し、ユーザー固有の処理やデータアクセスを安全に提供できるようにする。なお、Next.js側でも必要に応じてApp Routerの仕組みによるAPIルートを定義し、簡易なサーバレス処理（例: フォームデータの送信処理や、SEO目的のサイトマップ生成など）を実装する場合がある。ただし、コアとなるビジネスロジックや外部サービス連携処理は、メンテナンス性とスケーラビリティの観点からFastAPIサーバに集約させる。

## 実装計画

### モノレポ構成

ソースコードはモノレポジトリ構成で管理する。リポジトリ内にモバイルアプリとWebアプリ、共通のパッケージ群を含め、依存関係を一元的に解決する。パッケージマネージャーはYarn/NPMワークスペースを使用し、Turborepoによりビルドや依存関係のキャッシュを最適化する。プロジェクトディレクトリの構造は次のとおりである:

```
scaffai/
├── apps/
│   ├── mobile/      (ExpoによるReact Nativeモバイルアプリ)
│   └── web/         (Next.jsによるWebアプリ)
└── packages/
    ├── ui/          (@scaffai/ui 共通UIコンポーネントライブラリ)
    └── core/        (@scaffai/core 共通のビジネスロジック・データ処理)
```

各アプリケーションは上記の共通パッケージをインポートして利用する。型定義やユーティリティは@scaffai/coreで共有されるため、モバイルとWeb間でロジックが重複しない。Turborepoのタスク定義により、モバイルアプリのビルド・Webアプリのビルド/デプロイ・テスト・リンティングなどを並列またはキャッシュ付きで実行でき、CI/CD環境でも効率良く動作する。

### モバイルアプリ (Expo)

Expoプラットフォーム上でReact Nativeにより実装する。Expo SDK 53とExpo Router v3を採用しており、apps/mobile内のapp/ディレクトリ配下に画面コンポーネント（スクリーン）を配置することで自動的にルーティングが構成される。Expo Router v3はファイルベースのルーティングフレームワークで、React Navigation v6を基盤としており、フォルダ構成に沿ってスタック画面やタブ画面を宣言的に定義できる。これにより、例えばapp/profile.tsxを配置すればプロフィール画面へのルートが生成され、Android/iOS双方でネイティブに近い画面遷移が実現できる。

モバイルアプリでは、NativeWind 4.xやExpo SDK 53の各種モジュール（カメラ、ローカルストレージ、位置情報など）を活用して、ネイティブ機能と一体化したユーザ体験を提供する。開発言語はTypeScript 5.xを用い、React 19のHooksベースで機能を実装する。ビルドおよび配布はExpo EAS（Expo Application Services）を用いて行い、iOS TestFlightやAndroid内部テストへの継続的デプロイを行う。ExpoのOTA（Over-The-Air）アップデート機能も活用可能であり、軽微な修正であればストア審査を経ずにユーザへデプロイできる。最終的なモバイルアプリはApp StoreおよびGoogle Playストアで公開予定である。

### Webアプリ (Next.js)

Next.js 15.1.8を用いて実装する。App Router（app/ディレクトリ）を使用したファイルベースルーティングによりページとAPIを構築する。PagesはReact 19のサーバコンポーネント/クライアントコンポーネントを適材適所で使い分け、高速な初期表示と対話性を両立する。Next.js 15では`params`、`searchParams`、`cookies()`、`headers()`等が非同期化されているため、適切に`await`キーワードを使用して実装する。必要に応じてSSG/SSRを活用し、初回ロードを最適化する（例えば、マーケティング用の静的ページはビルド時に生成し、ユーザ固有のダッシュボードは動的レンダリングする）。

UIはRadix UI v1とTailwind CSS v4を組み合わせて構築し、コンポーネントは可能な限り@scaffai/uiから供給する。Next.js 15のApp Routerでは、ディレクトリ構造に基づき自動でルーティングとコード分割が行われるため、開発者はページコンポーネントとレイアウトコンポーネントを定義するだけでよい。Web固有の機能（例: ブラウザのファイル入力、クリップボード操作など）はReactのエフェクトフックやブラウザAPIを用いて実装する。WebアプリもTypeScript 5.xで記述し、React 19の機能（サスペンスやサーバコンポーネント）を活かした最新の実装スタイルとする。デプロイはVercelプラットフォームを利用し、Gitリポジトリへのプッシュをトリガーとして自動ビルド・デプロイ（Preview/Production環境）を行う。

### 共有パッケージ（UIとCore）

上記のモバイル・Web両アプリから参照される共有パッケージとして、@scaffai/uiと@scaffai/coreを実装する。@scaffai/uiには前述の通りデザインシステムに沿ったUIコンポーネントを定義する。ボタン、テキスト入力、モーダルなどのコンポーネントをプラットフォーム横断的に利用できるAPIで提供し、一部の実装はプラットフォームごとに分岐する（例えば、Buttonコンポーネントは内部でWebの場合はRadix UIのボタン、ネイティブの場合はPressableを用いるが、共通のプロパティで使用できるようにする）。これにより、開発者は共通の部品をインポートして使うだけで、それぞれの環境に最適化されたUIが描画される。

@scaffai/coreにはビジネスロジックやユーティリティ関数、データアクセスコードを集約する。具体的には、Supabaseクライアントの初期化とラップ、各APIエンドポイントと通信する関数、認証・セッション管理、そしてアプリ内のグローバル状態管理ロジックを含む。ドメインオブジェクトごとにモジュールを分け、例えばユーザー管理用の変数・関数群（新規ユーザー作成、プロフィール更新等）、プロジェクト管理用の関数群（プロジェクト作成・編集・削除等）といった構造にする。こうしたコアロジックを共有することで、プラットフォーム間で動作を統一しつつ、一箇所の変更が両方に反映され、バグの低減と開発効率の向上が期待できる。

### ルーティング戦略

前述のとおり、モバイルはExpo Router、WebはNext.js App Routerによるルーティングを採用する。それぞれファイルシステムに沿った宣言的なルート定義が可能であり、画面遷移を直感的に管理できる。モバイル側ではスタックナビゲーションやタブナビゲーションもファイル構造（フォルダ名に(tabs)を含める等）で表現でき、Web側ではレイアウトとページを組み合わせた柔軟な画面構成が可能である。両者で画面のURL構造/パスを可能な範囲で合わせることで、開発者が機能対応する際に認識しやすくする。主要な画面のルート例を以下に示す:

#### モバイル (Expo Router)

app/ ディレクトリ以下に各画面を定義する。一例:

```
app/
 ├─ index.tsx          （ホーム画面）
 ├─ login.tsx          （ログイン画面）
 ├─ signup.tsx         （サインアップ画面）
 ├─ profile.tsx        （プロフィール画面）
 └─ projects/
      ├─ _layout.tsx   （プロジェクト画面のレイアウト）
      └─ [id].tsx      （プロジェクト詳細画面、idは動的パラメータ）
```

上記のように、_layout.tsxを配置することでプロジェクト関連画面に共通のレイアウト（例えばタブやヘッダー）を適用し、[id].tsxで動的な詳細ページを実装できる。

#### Web (Next.js App Router)

app/ ディレクトリ以下にページ (page.tsx)やレイアウト (layout.tsx)を定義する。一例:

```
app/
 ├─ page.tsx                   （ホームページ）
 ├─ login/
 │    └─ page.tsx              （ログインページ）
 ├─ signup/
 │    └─ page.tsx              （サインアップページ）
 ├─ profile/
 │    └─ page.tsx              （プロフィールページ）
 └─ projects/
      ├─ layout.tsx           （プロジェクト関連ページ共通レイアウト）
      ├─ page.tsx             （プロジェクト一覧ページ）
      └─ [id]/
           └─ page.tsx        （プロジェクト詳細ページ、[id]は動的パラメータ）
```

Next.jsでは自動的にURLパスがディレクトリ構造から生成される。layout.tsxはその配下のpage.tsx群の共通レイアウト（ナビゲーションバー等）を定義するのに使われる。上記例では、/projectsでプロジェクト一覧を表示し、/projects/123でIDが123のプロジェクト詳細を表示することになる。

### 状態管理戦略

アプリケーションの状態管理については、グローバル状態とサーバデータ状態の双方を適切に扱う。グローバルなUI状態（ログインしているか否か、現在表示中のテーマ、通知の件数など）については、ReactのContext APIや軽量な状態管理ライブラリ（例: Zustand）を用いて管理する。例えば、ユーザーのログイン状態やプロフィール情報はAuthContext（またはそれに類する仕組み）でアプリ全体に提供し、どの画面からでも参照・更新できるようにする。

一方、サーバから取得するデータ（SupabaseのDBやFastAPIからの応答データ）については、キャッシュやデータフェッチの効率化のために専用のライブラリを利用する。具体的にはTanStack Query v5を導入し、データ取得・変更の処理と結果キャッシュを一元管理する。TanStack Query v5を使うことで、データのフェッチ状況（ロード中・エラー状態）やキャッシュの保存・無効化が簡潔に扱え、オフライン時の一時的なキャッシュ参照やバックグラウンドでの再同期も自動化できる。

リアルタイム更新が必要なデータについては、Supabaseのリアルタイムリスナーから受け取ったイベントをトリガーに、上記のキャッシュを更新する仕組みを組み込む。例えば、TanStack Queryのinvalidate機能や、状態管理ストア内でリスナーを購読して該当データを差し替える処理を行う。こうして、明示的な再読み込み操作を不要にしつつデータの整合性を保つ。

なお、モバイルとWebで共通するロジックは極力@scaffai/core側に集約し（例えばデータ取得用の共通フックをcore内に定義する）、各UI側ではそれらを呼び出すことで状態管理の重複を防ぐ。必要に応じて、プラットフォームごとのストレージ（React NativeならAsyncStorage、WebならlocalStorageなど）を利用し、ユーザーデータや設定を永続化してオフライン環境でも直近のデータを表示できるようにする。

## 非機能要件

### パフォーマンス

モバイル・Web双方のアプリにおいて高速で滑らかな動作を実現する。アプリ起動から初期画面表示までの時間を短く保ち（目標: 数秒以内）、ユーザー操作に対して60fpsでのレスポンスを維持する。これを達成するため、コード分割や遅延読み込みを活用して不要なリソースの一括読み込みを避ける。WebではNext.jsのビルトイン機能により初期バンドルサイズを削減し、重要度の低いコンポーネントは動的インポートする。モバイルでは画面遷移ごとに必要なリソースのみを読み込むようExpo Routerの仕組みを利用する。また、画像や動画などのメディアは適切にリサイズ・圧縮したものを配信し、Supabase StorageのCDN機能を活用して低遅延で提供する。データベースクエリについては必要なインデックスの付与やN+1クエリの回避などバックエンド側も最適化し、クライアント側では結果を適切にキャッシュすることで不要な再取得を減らす。パフォーマンスの指標（例：ページロード時間、API応答時間、アニメーションフレーム落ち数など）は開発段階から計測し、継続的にチューニングを行う。

### オフライン対応

ネットワーク未接続時でも可能な範囲でアプリの主要機能が利用できるようにする。具体的には、直前に取得したデータをデバイスにキャッシュしておき閲覧可能とし、再接続時に自動で最新データに同期する仕組みを導入する。モバイルアプリではAsyncStorageやSQLiteを用いてローカルデータベースに重要情報を保存し、WebアプリではブラウザのIndexedDBやローカルストレージにキャッシュを保持する。ユーザーがオフラインで行った更新操作については、一時的にデバイス内にキューイングし、オンライン復帰時にサーバに送信する（コンフリクトが発生した場合は最新サーバ状態を優先しつつユーザーに通知する戦略を取る）。また、ネットワーク状態を監視し、オフライン時にはその旨をUI上で明示してユーザーの混乱を避ける。必要に応じてWebアプリをProgressive Web App（PWA）化し、静的アセットを事前キャッシュすることでオフライン時でもアプリを起動・閲覧できるように検討する。

### アクセシビリティ

全てのユーザーにとって使いやすいアプリとなるよう、アクセシビリティに配慮した設計・実装を行う。WebアプリではWCAG 2.x（Web Content Accessibility Guidelines）に準拠し、適切なセマンティックHTMLタグの使用、ARIAラベルの付与、キーボード操作への完全対応などを徹底する。Radix UIの採用によって、多くのコンポーネントで標準的なキーボード操作やスクリーンリーダー対応が担保されている 。モバイルアプリにおいても、各種UIコンポーネントにアクセシビリティラベル（accessibilityLabel等）を設定し、VoiceOver/TalkBackといったスクリーンリーダーで情報が伝わるようにする。また、色覚の多様性に配慮し、コントラスト比の高いカラーパレットを採用する。フォントサイズはユーザーの端末設定に追従し、動的にスケーリング可能とする。定性的な対応だけでなく、定期的にアクセシビリティテストを実施し、視覚・聴覚に障害のあるユーザーからのフィードバックを取り入れて改善を図る。

### CI/CDパイプライン

開発から本番リリースまでのプロセスを自動化し、高いリリース頻度と品質を両立する。Gitにプッシュされたコードは自動的にCIによってビルド・テストが実行され、問題ない場合にデプロイがトリガーされる。モバイルアプリはExpo EASを用いたCI/CDを構築し、プルリクエスト単位でのビルド検証や、メインブランチへのマージ時に自動的に最新バイナリを作成する。必要に応じて内部テスト用にデプロイし、リリース準備が整い次第、App Store ConnectやGoogle Play Consoleへアップロードして審査を待つ運用とする。WebアプリはVercelと連携し、ブランチごとにPreviewデプロイを行って動作確認を経た上で、本番ブランチへのマージで自動的に本番環境へデプロイされる。環境変数（SupabaseのAPI鍵など）の管理はVercelおよびEASの設定で安全に行い、シークレット情報がリポジトリに含まれないようにする。また、CIパイプラインでは静的解析（リントや型チェック）、単体テストの実行、脆弱性スキャンなども組み込み、品質ゲートを設ける。これにより、人為的ミスを減らしつつ継続的デリバリーを実現する。